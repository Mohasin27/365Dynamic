/*--------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * See License.txt in the project root for license information.
 *--------------------------------------------------------------*/

/* eslint-disable no-duplicate-imports */
import {
    IAddToOrderTemplateDialogResources, IDuplicateItemsWhenAddingToOrderTemplateDialogResources,
    IItemAddedToOrderTemplateDialogResources, ILinesAddedToOrderTemplateDialogResources, IOrderTemplateNameDialogResources,
    IWishlistActionSuccessResult, PromoCodeComponent, SaveCartToOrderTemplateComponent } from '@msdyn365-commerce/components';
import MsDyn365, { getUrlSync, IImageSettings } from '@msdyn365-commerce/core';
import { ICartActionResult, ICartState } from '@msdyn365-commerce/global-state';
import { AsyncResult, CartLine, LineDataValidationFailure, SimpleProduct } from '@msdyn365-commerce/retail-proxy';
import { ReleasedProductType } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { cartLineQuantityUpdatedAsync, validateCartAsync } from '@msdyn365-commerce-modules/cart-utilities';
import { IInvoiceSummaryLines, InvoiceSummary } from '@msdyn365-commerce-modules/invoice-payment-summary';
import { IOrderSummaryLines, OrderSummary } from '@msdyn365-commerce-modules/order-summary-utilities';
import { ActiveCartProductsInput, ArrayExtensions, getActiveCartProductsAction, ObjectExtensions } from '@msdyn365-commerce-modules/retail-actions';
import { Alert, Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, INodeProps, IPayLoad,
    ITelemetryContent, TelemetryConstant, Waiting } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import { reaction } from 'mobx';
import { observer } from 'mobx-react';
import React from 'react';

import { ICartData } from './cart.data';
import { ICartProps, ICartResources } from './cart.props.autogenerated';
import { CartLineGroupItems } from './components/cart-line-groups';
import { CartLineItems, ICartlinesViewProps } from './components/cart-line-items';
import { cartPromotions, ICartLineItemViewProps } from './components/cart-line-items-promotion';
import { getPromotionData, IPromotionData } from './utils/get-promotion-in-cart';
import { getDateTimeslot } from '@msdyn365-commerce-modules/order-management';

export interface ICartViewProps extends ICartProps<ICartData> {
    className: string;
    title?: React.ReactNode;
    CartlinesWrapper: INodeProps;
    cartlines?: ICartlinesViewProps[];
    cartLinesGroup?: ICartlinesViewProps[][];
    cart: ICartState | undefined;
    orderSummaryHeading: React.ReactNode;
    orderSummaryLineitems?: IOrderSummaryLines;
    invoiceSummaryLineitems?: IInvoiceSummaryLines;
    OrderSummaryWrapper: INodeProps;
    OrderSummaryItems: INodeProps;
    OrderSummaryErrors?: IOrderSummaryErrors;
    checkoutAsGuestButton: React.ReactNode;
    checkoutAsSignInUserButton: React.ReactNode;
    storeSelector?: React.ReactNode;
    backToShoppingButton: React.ReactNode;
    waitingComponent: React.ReactNode;
    promotionOptions?: ICartLineItemViewProps;
    promoCode: React.ReactNode;
    cartLoadingStatus: string;
    cartDataResult: boolean;
    multiplePickUpEnabled?: boolean;
    createTemplateFromCartButton: React.ReactNode;
    telemetryContent?: ITelemetryContent;
    removeItemClickHandler(cartlineToRemove: CartLine): void;
    productExpirationMessage: string |undefined;
    moveToWishlistSuccessHandler(result: IWishlistActionSuccessResult, cartlineId: CartLine): void;
    
}

export interface IOrderSummaryErrors {
    Wrapper: INodeProps;

    header: React.ReactNode;
    errors: React.ReactNode[];
}

interface ICartComponentState {
    showPromotionDialog: boolean;
    cartlinesErrors: LineDataValidationFailure[];
    promotionData: IPromotionData;
    products: SimpleProduct[];
    isCartValid: boolean;
}

/**
 *
 * Cart component.
 * @extends {React.PureComponent<ICartProps<ICartData>>}
 */
@observer
class Cart extends React.Component<ICartProps<ICartData>> {

    public state: ICartComponentState = {
        cartlinesErrors: [],
        showPromotionDialog: false,
        promotionData: {},
        products: [],
        isCartValid: true
    };

    private readonly telemetryContent: ITelemetryContent;

    private readonly payLoad: IPayLoad;

    private isQuantityLimitsFeatureEnabled: boolean = false;

    private _isMounted: boolean = false;

    private readonly promotionPopupId: string = 'cart-promotion-popup';

    constructor(props: ICartProps<ICartData>) {
        super(props);
        this.telemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!, this.props.friendlyName, this.props.telemetry);
        this.payLoad = getPayloadObject('click', this.telemetryContent, '');
        this.promotionLinkClick = this.promotionLinkClick.bind(this);
        this.promotionCloseButtonclick = this.promotionCloseButtonclick.bind(this);
    }

    public async componentDidMount(): Promise<void> {
        this._isMounted = true;
        const {
            config,
            context: {
                actionContext
            }
        } = this.props;

        this.isQuantityLimitsFeatureEnabled = await this._getOrderQuantityLimitsFeatureFlag();
        if (this.isQuantityLimitsFeatureEnabled) {
            await this._validateCart();
        }

        try {
            const products = await this.props.data.products;
            if (this._isMounted) {
                this.setState({ products });
            }
        } catch (error) {
            this.props.telemetry.warning('error');
            this.props.telemetry.debug('Unable to get cart');
        }

        if (config.showAvailablePromotions) {
            if (this._isMounted && this.props.data.cart.result?.cart.CartLines) {
                this.setState({ promotionData: await getPromotionData(actionContext) });
            }

            reaction(
                () => this.props.data.cart.result?.cart.CartLines,
                async () => {
                    if (this._isMounted) {
                        this.setState({ promotionData: await getPromotionData(actionContext) });
                    }
                }
            );
        }
    }

    public componentWillUnmount(): void {
        this._isMounted = false;
    }

    public shouldComponentUpdate(nextProps: ICartProps<ICartData>,
        nextState: ICartComponentState): boolean {
        if (this.state === nextState && this.props.data === nextProps.data) {
            return false;
        }
        return true;
    }

    public render(): JSX.Element | null {
        const {
            data: {
                cart: { result: cart },
                products: { result: products }
            },
            context: {
                request: {
                    user: {
                        isAuthenticated,
                        signInUrl
                    }
                }
            },
            resources
        } = this.props;

        const guestCheckoutUrl = getUrlSync('checkout', this.props.context.actionContext) || '';
        const backToShoppingUrl = getUrlSync('home', this.props.context.actionContext) || '';
        const checkoutURL = this._getCheckoutURL(isAuthenticated, guestCheckoutUrl, signInUrl || '');
        const isCartEmpty = cart && cart.cart.CartLines && cart.cart.CartLines.length === 0;
        const cartLines = this._getCartLines();
        const hasError = !this.state.isCartValid || (cartLines ? cartLines.some(cartline => cartline.hasError) : false);
        const RetailMultiplePickupFeatureState = this.props.data.featureState.result?.find(featureState => featureState.Name === 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature');
        const multiplePickUpEnabled = !cart?.hasInvoiceLine && RetailMultiplePickupFeatureState?.IsEnabled;
        const cartLinesGroup = multiplePickUpEnabled ? this._getCartLinesGroup() : null;

        this.payLoad.contentAction.etext = TelemetryConstant.Checkout;
        const checkoutBySignInAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);
        this.payLoad.contentAction.etext = TelemetryConstant.GuestCheckout;
        const checkoutByGuestAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);
        this.payLoad.contentAction.etext = TelemetryConstant.BackToShopping;
        const backtoShoppingAttributes = getTelemetryAttributes(this.telemetryContent, this.payLoad);
       
        
        const viewProps = {
            ...this.props,
            className: classnames('ms-cart'),
            title: <h1 className='msc-cart__heading'>
                {resources.cartTitle}
            </h1>,
            cart: this.props.data.cart.result,
            CartlinesWrapper: { className: 'msc-cartline-wraper' },
            OrderSummaryWrapper: { className: cart?.hasInvoiceLine ? 'msc-invoice-summary-wrapper' : 'msc-order-summary-wrapper' },
            OrderSummaryItems: { className: cart?.hasInvoiceLine ? 'msc-invoice-summary__items' : 'msc-order-summary__items' },
            cartlines: cartLines,
            cartLinesGroup,
            promoCode: this._getPromoCode(),
            promotionOptions: this._getPromotions(),
            context: this.props.context,
            typeName: this.props.typeName,
            telemetry: this.props.telemetry,
            id: this.props.id,
            multiplePickUpEnabled,
            removePromoAriaLabelFormat: resources.removePromoAriaLabelFormat,
            orderSummaryHeading: ArrayExtensions.hasElements(cart?.cart.CartLines) ? (
                cart?.hasInvoiceLine ? <h2 className='msc-invoice-summary__heading'>
                    { resources.invoiceSummaryTitle }
                </h2> : <h2 className='msc-order-summary__heading'>
                    { resources.orderSummaryTitle}
                </h2>
            ) : null,
            orderSummaryLineitems: this._getOrderSummaryLineItems(),
            invoiceSummaryLineitems: this._getInvoiceSummaryLineItems(),
            checkoutAsSignInUserButton: (!isCartEmpty) ? (
                <Button
                    disabled={hasError} className='msc-cart__btn-checkout' href={checkoutURL}
                    title={resources.checkoutButtonTitle} {...checkoutBySignInAttributes} >
                    {resources.checkoutButtonTitle}
                </Button>
            ) : null,
            checkoutAsGuestButton: (!isCartEmpty && !isAuthenticated) ? (
                <Button
                    disabled={hasError} className='msc-cart__btn-guestcheckout' href={guestCheckoutUrl}
                    title={resources.guestCheckoutButtonTitle} {...checkoutByGuestAttributes}>
                    {resources.guestCheckoutButtonTitle}
                </Button>
            ) : null,
            backToShoppingButton: <Button
                className='msc-cart__btn-backtoshopping' {...backtoShoppingAttributes} href={backToShoppingUrl}
                title={resources.backToShoppingButtonTitle}>
                {resources.backToShoppingButtonTitle}
            </Button>,
            createTemplateFromCartButton: (this._displayAddCartToTemplate() && products) ? (
                <SaveCartToOrderTemplateComponent
                    addToOrderTemplateDialogResources={this._generateAddToOrderTemplateDialogResources(resources)}
                    createOrderTemplateDialogResources={this._generateOrderTemplateNameDialogResources(resources)}
                    linesAddedToOrderTemplateDialogResources={this._generateLinesAddedToOrderTemplateDialogResources(resources)}
                    createOrderTemplateFromCartButton={resources.createOrderTemplateFromCartButton}
                    createOrderTemplateFromCartButtonTooltip={resources.createOrderTemplateFromCartButtonTooltip}
                    context={this.props.context}
                    id={this.props.id}
                    typeName={this.props.typeName}
                    data={{
                        orderTemplates: this.props.data.orderTemplates.result!,
                        cartLines: this.props.data.cart.result!.cart.CartLines!,
                        customerInformation: this.props.data.customerInformation.result
                    }}
                />
            ) : null,
            storeSelector: this.props.slots.storeSelector && this.props.slots.storeSelector.length > 0 ? this.props.slots.storeSelector[0] : null,
            removeItemClickHandler: this._removeItemFromCartHandler,
            moveToWishlistSuccessHandler: this._moveToWishlistSuccessHandler,
            waitingComponent: <Waiting className='msc-waiting-circular msc-waiting-lg' />,
            cartLoadingStatus: this.props.data.cart.status === 'FAILED' ? this.props.resources.cartLoadingErrorMessage : null,
            cartDataResult: this.props.data.cart.result && this.props.data.cart.result.isEmpty,
            OrderSummaryErrors: this._getOrderSummaryErrors(cartLines),
            telemetryContent: this.telemetryContent,
            productExpirationMessage: this.props.data.expirationMessage.result?.message
        };

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    private readonly promotionLinkClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        this.setState({
            showPromotionDialog: !this.state.showPromotionDialog
        });
    };

    private readonly promotionCloseButtonclick = () => {
        this._hidePromotionDialog();
    };

    private _hidePromotionDialog(): void {
        this.setState({
            showPromotionDialog: false
        });
    }

    private _displayAddCartToTemplate(): boolean {
        const cart = this.props.data.cart?.result;
        if (ObjectExtensions.isNullOrUndefined(cart) || cart.hasInvoiceLine) {
            return false;
        }

        const RetailB2BEcommerceFeatureState = this.props.data.featureState.result?.find(featureState => featureState.Name === 'Dynamics.AX.Application.RetailB2BEcommerceFeature');
        if (RetailB2BEcommerceFeatureState?.IsEnabled && this.props.data.customerInformation.result?.IsB2b && this.props.data.orderTemplates.result &&
            ArrayExtensions.hasElements(cart.cart?.CartLines) && this.props.data.customerInformation.result) {
            return true;
        }

        return false;
    }

    private _getPromotions(): React.ReactNode {
        return (
            this.props.config.showAvailablePromotions &&
            cartPromotions({
                id: this.promotionPopupId,
                showPromotionPopup: this.state.showPromotionDialog,
                onSeeAllClick: this.promotionLinkClick,
                onCloseButtonClick: this.promotionCloseButtonclick,
                promotions: this.state.promotionData.promotionOptions,
                resources: {
                    promotionStringHeading: this.props.resources.promotionStringHeading,
                    promotionLinkText: this.props.resources.promotionLinkText,
                    promotionPopupHeading: this.props.resources.promotionPopupHeading,
                    promotionCloseButtonAriaLabel: this.props.resources.promotionCloseButtonAriaLabel
                }
            })
        );
    }

    private _getOrderSummaryErrors(cartLines: ICartlinesViewProps[] | null): IOrderSummaryErrors | undefined {
        const allErrors = cartLines && cartLines.map(cartline => {

            // Check if the product is service or not by product type
            const isServiceItem = cartline.data?.product?.ItemTypeValue === ReleasedProductType.Service;

            if (!isServiceItem && cartline.error) {
                const fullError = (cartline.data && cartline.data.product?.Name) ? `${cartline.data.product.Name}: ${cartline.error}` : cartline.error;

                return (
                    <div className='msc-alert__line'>
                        {fullError}
                    </div>
                );
            }

            return null;
        }).filter((line): line is JSX.Element => !!line) || [];

        return {
            Wrapper: {
                tag: Alert,
                className: 'msc-alert',
                isOpen: allErrors.length > 0,
                color: 'danger',
                assertive: true,
                'aria-label': this.props.resources.outOfStockErrorMessageHeader
            },
            header: (
                <div className='msc-alert__header' aria-hidden='true'>
                    <span className='msi-exclamation-triangle' />
                    <span>
                        {this.props.resources.outOfStockErrorMessageHeader}
                    </span>
                </div>
            ),
            errors: allErrors
        };
    }

    private _getInvoiceSummaryLineItems(): IInvoiceSummaryLines | undefined {
        const {
            data: {
                cart: { result: cart }
            },
            telemetry,
            resources
        } = this.props;

        return cart?.hasInvoiceLine ? (
            InvoiceSummary({
                orderTotalLabel: resources.totalAmountLabel,
                invoiceLabel: resources.invoiceLabel,
                cart: cart.cart,
                context: this.props.context,
                typeName: this.props.typeName,
                telemetry,
                id: this.props.id
            })
        ) : undefined;
    }

    private _getOrderSummaryLineItems(): IOrderSummaryLines | undefined {
        const {
            data: {
                cart: { result: cart },
                channelDeliveryOptionConfig
            },
            telemetry,
            resources
        } = this.props;
        console.log("this.props");
        console.log(this.props);
        const channelConfiguration = this.props.context && this.props.context.request && this.props.context.request.channel;
        const multiplePickupStoreSwitchName = 'Dynamics.AX.Application.RetailMultiplePickupDeliveryModeFeature';
        const featureState = this.props?.data?.featureState;
        const retailMultiplePickUpOptionEnabled = featureState?.result?.find(item => item.Name === multiplePickupStoreSwitchName)?.IsEnabled;
        
        var tes = channelConfiguration && ArrayExtensions.hasElements(cart?.cart.CartLines) && !cart?.hasInvoiceLine ? (
            OrderSummary({
                cart: cart!.cart,
                subTotalLabel: resources.itemsWithCountLabel,
                shippingLabel: resources.estimatedShippingLabel,
                otherChargeLabel: resources.otherCharges,
                taxLabel: resources.estimatedTaxLabel,
                orderTotalLabel: resources.orderTotal,
                totalDiscountsLabel: resources.totalDiscountsLabel,
                context: this.props.context,
                typeName: this.props.typeName,
                id: this.props.id,
                toBeCalculatedText: resources.yetToBeCalculatedText,
                freeText: resources.priceFree,
                channelConfiguration,
                retailMultiplePickUpOptionEnabled,
                channelDeliveryOptionConfig: channelDeliveryOptionConfig?.result,            
                telemetry,
                
            })
        ) : undefined;

        console.log(tes);

        return channelConfiguration && ArrayExtensions.hasElements(cart?.cart.CartLines) && !cart?.hasInvoiceLine ? (
            OrderSummary({
                cart: cart!.cart,
                subTotalLabel: resources.itemsWithCountLabel,
                shippingLabel: resources.estimatedShippingLabel,
                otherChargeLabel: resources.otherCharges,
                taxLabel: resources.estimatedTaxLabel,
                orderTotalLabel: resources.orderTotal,
                totalDiscountsLabel: resources.totalDiscountsLabel,
                context: this.props.context,
                typeName: this.props.typeName,
                id: this.props.id,
                toBeCalculatedText: resources.yetToBeCalculatedText,
                freeText: resources.priceFree,
                channelConfiguration,
                retailMultiplePickUpOptionEnabled,
                channelDeliveryOptionConfig: channelDeliveryOptionConfig?.result,            
                telemetry,
                
            })
        ) : undefined;
    }

    private _getPromoCode(): React.ReactNode {
        const {
            data: {
                cart: { result: cart }
            },
            resources
        } = this.props;

        return cart && (
            <PromoCodeComponent
                cart={cart}
                promoCodeHeadingText={resources.promoCodeHeadingText}
                promoPlaceholderText={resources.promoPlaceholderText}
                promoCodeApplyButtonText={resources.promoCodeApplyButtonText}
                appliedPromoCodeHeadingText={resources.appliedPromoCodeHeadingText}
                collapseTimeOut={350}
                removePromoAriaLabelFormat={resources.removePromoAriaLabelFormat}
                removePromoText={resources.removePromoText}
                invalidPromoCodeErrorText={resources.invalidPromoCodeErrorText}
                failedToAddPromoCodeErrorText={resources.failedToAddPromoCodeErrorText}
                failedToRemovePromoCodeErrorText={resources.failedToRemovePromoCodeErrorText}
                duplicatePromoCodeErrorText={resources.duplicatePromotionErrorText}
                context={this.props.context}
                id={this.props.id}
                typeName={this.props.typeName}
                data={{}}
                telemetryContent={this.telemetryContent}
            />
        );
    }

    private _generateAddToOrderTemplateDialogResources(resources: ICartResources): IAddToOrderTemplateDialogResources {
        return {
            addToOrderTemplateHeader: resources.addToOrderTemplateHeader,

            noOrderTemplatesMessage: resources.noOrderTemplatesMessage,
            noOrderTemplatesDescription: resources.noOrderTemplatesDescription,

            createAnOrderTemplateButtonText: resources.createAnOrderTemplateButtonText,
            createNewOrderTemplateButtonText: resources.createNewOrderTemplateButtonText,
            cancelOrderTemplateCreationButtonText: resources.cancelOrderTemplateCreationButtonText,

            selectTemplatesText: resources.selectTemplatesText,
            addToTemplateButtonText: resources.addToTemplateButtonText,
            lineItemsText: resources.lineItemsText
        };
    }

    private _generateItemAddedToOrderTemplateDialogResources(resources: ICartResources): IItemAddedToOrderTemplateDialogResources {
        return {
            viewOrderTemplateButtonText: resources.viewOrderTemplateButtonText,
            continueShoppingButtonText: resources.continueShoppingButtonText,
            itemAddedToOrderTemplateHeaderItemOneText: resources.itemAddedToOrderTemplateHeaderItemOneText,
            itemAddedToOrderTemplateHeaderItemFormatText: resources.itemAddedToOrderTemplateHeaderItemFormatText,
            itemAddedToOrderTemplateHeaderMessageText: resources.itemAddedToOrderTemplateHeaderMessageText,
            freePriceText: resources.freePriceText,
            originalPriceText: resources.originalPriceText,
            currentPriceText: resources.currentPriceText
        };
    }

    private _generateLinesAddedToOrderTemplateDialogResources(resources: ICartResources): ILinesAddedToOrderTemplateDialogResources {
        return {
            viewOrderTemplateButtonText: resources.viewOrderTemplateButtonText,
            continueShoppingButtonText: resources.continueShoppingButtonText,
            linesAddedToOrderTemplateHeaderItemsOneText: resources.linesAddedToOrderTemplateHeaderItemsOneText,
            linesAddedToOrderTemplateHeaderItemsFormatText: resources.linesAddedToOrderTemplateHeaderItemsFormatText,
            linesAddedToOrderTemplateHeaderLinesOneText: resources.linesAddedToOrderTemplateHeaderLinesOneText,
            linesAddedToOrderTemplateHeaderLinesFormatText: resources.linesAddedToOrderTemplateHeaderLinesFormatText,
            linesAddedToOrderTemplateHeaderMessageText: resources.linesAddedToOrderTemplateHeaderMessageText,
            linesAddedToOrderTemplateCustomPriceAlertMessageText: resources.linesAddedToOrderTemplateCustomPriceAlertMessageText
        };
    }

    private _generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(resources: ICartResources): IDuplicateItemsWhenAddingToOrderTemplateDialogResources {
        return {
            duplicatedProductsHeader: resources.duplicatedProductsHeader,
            duplicatedProductsDescription: resources.duplicatedProductsDescription,
            updateQuantityButtonText: resources.updateQuantityButtonText,
            cancelDuplicateItemsButtonText: resources.cancelDuplicateItemsButtonText
        };
    }

    private _generateOrderTemplateNameDialogResources(resources: ICartResources): IOrderTemplateNameDialogResources {
        return {
            orderTemplateHeaderLabel: resources.createOrderTemplateHeader,
            orderTemplateTitleLabel: resources.orderTemplateTitle,
            orderTemplateNameAriaLabel: resources.orderTemplateNameAriaLabel,
            orderTemplateDescription: resources.createOrderTemplateDescription,

            defaultOrderTemplateName: resources.defaultOrderTemplateName,

            orderTemplateButtonLabel: resources.createOrderTemplateButtonText,
            orderTemplateCancelButtonLabel: resources.cancelNewOrderTemplateCreationButtonText
        };
    }

    private _getCartLines(): ICartlinesViewProps[] | null {
        const {
            data: {
                cart: { result: cart },
                wishlists: { result: wishlists },
                orderTemplates: { result: orderTemplates },
                customerInformation: { result: customerInformation }
            },
            context: {
                request: {
                    channel: {
                        PickupDeliveryModeCode
                    } = { PickupDeliveryModeCode: undefined }
                }
            },
            config,
            telemetry,
            resources,
            modules
        } = this.props;

        const imageSettings = this._getImageSettings(config.imageSettings);

        const cartlinesErrors: LineDataValidationFailure[] = this.state.cartlinesErrors;
        let storeSelectorId: string = '';
        if (modules && Object.keys(modules).length > 0 && modules.storeSelector && modules.storeSelector.length > 0) {
            storeSelectorId = modules.storeSelector[0].id;
        }
        return ArrayExtensions.hasElements(cart?.cart.CartLines) ? (
            CartLineItems({
                cartlines: cart!.cart.CartLines,
                storeSelectorModuleId: storeSelectorId,
                cartlinesErrors,
                products: this.state.products,
                productAvailabilites: this.props.data.productAvailabilites.result,
                productDeliveryOptions: this.props.data.deliveryOptions.result,
                imageSettings,
                isStockCheckEnabled: this.props.context.app.config.enableStockCheck || false,
                maxCartlineQuantity: this.props.context.app.config.maxQuantityForCartLineItem,
                shouldIgnoreWarehouse: this.props.context.app.config.warehouseAggregation === 'multiple',
                gridSettings: this.props.context.request.gridSettings!,
                context: this.props.context,
                typeName: this.props.typeName,
                id: this.props.id,
                resources: {
                    sizeString: resources.productDimensionTypeSize,
                    colorString: resources.productDimensionTypeColor,
                    configString: resources.productDimensionTypeConfiguration,
                    styleString: resources.productDimensionTypeStyle,
                    amountString: resources.productDimensionTypeAmount,
                    quantityDisplayString: resources.quantityDisplayText,
                    inputQuantityAriaLabel: resources.inputQuantityAriaLabel,
                    decrementButtonAriaLabel: resources.decrementButtonAriaLabel,
                    incrementButtonAriaLabel: resources.incrementButtonAriaLabel,
                    discountStringText: resources.discountStringText,
                    originalPriceText: resources.originalPriceText,
                    currentPriceText: resources.currentPriceText,
                    shippingChargesText: resources.shippingCharges
                },
                telemetry,
                addToWishlistButtonText: resources.addToWishlistButtonText,
                removeFromWishlistButtonText: resources.removeFromWishlistButtonText,
                removeButtonText: resources.removeCartButtonText,
                shipItText: resources.shipInsteadDisplayText,
                pickitUpText: resources.pickItUpDisplayText,
                changeStoreText: resources.changeStoreDisplayText,
                storeSelectorStateManager: this.props.data.storeSelectorStateManager.result,
                outOfStockText: resources.outOfStockErrorMessage,
                outOfRangeOneText: resources.errorMessageOutOfRangeOneLeft,
                outOfRangeFormatText: resources.errorMessageOutOfRangeFormat,
                cartState: this.props.data.cart.result,
                orgUnitLocations: this.props.data.orgUnitLocations.result,
                removeItemClickHandler: this._removeItemFromCartHandler,
                moveToWishlistSuccessHandler: this._moveToWishlistSuccessHandler,
                updateCartLinesQuantitySuccessHandler: this._updateCartlineQuantity,
                locationChangedHandler: this._fulfillmentStoreIdUpdated,
                wishlists,
                defaultWishlistName: resources.defaultWishlistName,
                pickupDeliveryModeCode: PickupDeliveryModeCode,
                includeErrors: config.showOutOfStockErrors,
                showShippingChargesForLineItems: config.showShippingChargesForLineItems,
                telemetryContent: this.telemetryContent,
                isQuantityLimitsFeatureEnabled: this.isQuantityLimitsFeatureEnabled,

                addToOrderTemplateDialogResources: this._generateAddToOrderTemplateDialogResources(resources),
                createOrderTemplateDialogResources: this._generateOrderTemplateNameDialogResources(resources),
                itemAddedToOrderTemplateDialogResources: this._generateItemAddedToOrderTemplateDialogResources(resources),
                duplicateItemsWhenAddingToOrderTemplateDialogResources: this._generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(resources),

                addToOrderTemplateButtonText: resources.addToOrderTemplateButtonText,
                addToOrderTemplateButtonTooltip: resources.addToOrderTemplateButtonTooltip,
                addToOrderTemplateMessage: resources.addToOrderTemplateMessage,
                addItemToOrderTemplateError: resources.addItemToOrderTemplateError,
                orderTemplates,
                customerInformation,
                productExpirationMessage: this.props.data.expirationMessage.result?.message
            })
        ) : null;
    }

    private _getCheckoutURL(isAuthenticated: boolean, guestCheckoutUrl: string, signInUrl: string): string {
        if (isAuthenticated) {
            return guestCheckoutUrl;
        }

        const absoluteUrlRegExp = new RegExp('^(?:[a-z]+:)?//', 'i');
        const isAbsoluteUrl = absoluteUrlRegExp.test(guestCheckoutUrl);
        let returnURL = guestCheckoutUrl;
        if (MsDyn365.isBrowser && !isAbsoluteUrl) {
            returnURL = `${window.location.origin}${guestCheckoutUrl}`;
        }

        return `${signInUrl}${!signInUrl.includes('?') ? '?' : '&'}ru=${returnURL}`;
    }

    private readonly _getImageSettings = (imageSettings: IImageSettings | undefined): IImageSettings => {
        return imageSettings || {
            viewports: {
                xs: { q: 'w=80&h=94&m=6', w: 0, h: 0 },
                sm: { q: 'w=148&h=174&m=6', w: 0, h: 0 },
                lg: { q: 'w=148&h=174&m=6', w: 0, h: 0 }
            },
            lazyload: true
        };
    };

    private readonly _removeItemFromCartHandler = (cartlineToRemove: CartLine) => {
        if (this.props.data.cart.result) {
            const input = {
                cartLineIds: [cartlineToRemove.LineId!.toString()]
            };
            this.props.data.cart.result.removeCartLines(input)
                .then(() => {
                    this._validateCart()
                        .catch((error) => {
                            this.props.telemetry.warning(error);
                            this.props.telemetry.debug('Unable to validate Cart');
                        });
                })
                .catch((error) => {
                    this.props.telemetry.warning(error);
                    this.props.telemetry.debug('Unable to Remove Cart Line');
                });
        }
    };

    private readonly _moveToWishlistSuccessHandler = (result: IWishlistActionSuccessResult, cartline?: CartLine) => {
        if (result.status === 'ADDED' && cartline) {
            this._removeItemFromCartHandler(cartline);
        }
    };

    private readonly _updateCartlineQuantity = (cartlineToUpdate: CartLine, quantity: number, lineIndex?: number): boolean => {
        cartLineQuantityUpdatedAsync(
            this.isQuantityLimitsFeatureEnabled,
            this.props.data.cart.result,
            this.props.telemetry,
            this.state.products,
            cartlineToUpdate,
            quantity)
            .then((cartActionResult: ICartActionResult | undefined): boolean => {
                if (cartActionResult?.status === 'SUCCESS') {
                    this._validateCart().catch((error) => {
                        this.props.telemetry.warning((error as Error).message);
                        this.props.telemetry.debug('Unable to validate Cart');
                    });

                    return true;
                }

                if (!ObjectExtensions.isNullOrUndefined(cartActionResult)) {
                    // Show update line error message.
                    const defaultIndex = 0;
                    const lineUpdateFailure: LineDataValidationFailure = {
                        LineIndex: ObjectExtensions.isNullOrUndefined(lineIndex) ? defaultIndex : lineIndex,
                        DataValidationFailure: {
                            ErrorContext:
                        ArrayExtensions.hasElements(cartActionResult.validationResults) ? cartActionResult.validationResults[0].ErrorContext : '',
                            LocalizedMessage: cartActionResult.errorDetails?.LocalizedMessage
                        }
                    };

                    this.setState((previousState: Readonly<ICartComponentState>) => {
                        const currentErrors: LineDataValidationFailure[] = previousState.cartlinesErrors.filter(error => error.LineIndex !== lineIndex);
                        currentErrors.push(lineUpdateFailure);
                        return { cartlinesErrors: currentErrors };
                    });
                }

                return false;
            })
            .catch(() => {
                return false;
            });

        return false;
    };

    private readonly _fulfillmentStoreIdUpdated = () => {
        if (this.isQuantityLimitsFeatureEnabled) {
            getActiveCartProductsAction(new ActiveCartProductsInput(), this.props.context.actionContext)
                .then(products => {
                    this.setState({ products });
                })
                .then(async () => this._validateCart())
                .catch((error: Error) => {
                    this.props.telemetry.warning(error.message);
                    this.props.telemetry.debug('Unable to validate Cart');
                });
        }
    };

    private async _validateCart(): Promise<void> {
        const {
            data: { cart },
            telemetry,
            context
        } = this.props;

        const validationResults: LineDataValidationFailure[] | undefined = await validateCartAsync(this.isQuantityLimitsFeatureEnabled,
            cart,
            telemetry,
            context,
            true);

        if (validationResults) {
            const isValid = !ArrayExtensions.hasElements(validationResults);
            this.setState({
                cartlinesErrors: validationResults,
                isCartValid: isValid
            });
        } else {
            this.setState({ isCartValid: true });
        }

        return AsyncResult.resolve();
    }

    private async _getOrderQuantityLimitsFeatureFlag(): Promise<boolean> {
        const defaultOrderQuantityLimitsFeatureConfig = this.props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;
        if (defaultOrderQuantityLimitsFeatureConfig === 'none') {
            return false;
        }

        try {
            const featureStatuses = await this.props.data.featureState;
            const isQuantityLimitsFeatureEnabledInHq = featureStatuses
                .find(featureState => featureState.Name === 'Dynamics.AX.Application.RetailDefaultOrderQuantityLimitsFeature')?.IsEnabled || false;
            if (!isQuantityLimitsFeatureEnabledInHq) {
                return false;
            }
        } catch (error) {
          //  this.props.telemetry.warning();
            this.props.telemetry.debug('Unable to get feature states');
            return false;
        }

        if (defaultOrderQuantityLimitsFeatureConfig === 'all') {
            return true;
        }
        try {
            const customerInfo = await this.props.data.customerInformation;
            return !!customerInfo &&
            ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && customerInfo.IsB2b) ||
            (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !customerInfo.IsB2b));
        } catch (error) {
           // this.props.telemetry.warning(error);
            this.props.telemetry.debug('Unable to get customer info');
            return false;
        }
    }

    private _getCartLinesGroup(): ICartlinesViewProps[][] | null {
        const {
            data: {
                cart: { result: cart },
                wishlists: { result: wishlists },
                orderTemplates: { result: orderTemplates },
                customerInformation: { result: customerInformation }
            },
            context: {
                request: {
                    channel: {
                        PickupDeliveryModeCode
                    } = { PickupDeliveryModeCode: undefined }
                }
            },
            config,
            telemetry,
            resources,
            modules
        } = this.props;

        const imageSettings = this._getImageSettings(config.imageSettings);
        const cartlinesErrors: LineDataValidationFailure[] = this.state.cartlinesErrors;
        let storeSelectorId: string = '';
        if (modules && Object.keys(modules).length > 0 && modules.storeSelector && modules.storeSelector.length > 0) {
            storeSelectorId = modules.storeSelector[0].id;
        }

        return this.props.data.products && this.props.data.products.result && cart && cart.cart.CartLines && cart.cart.CartLines.length > 0 && this.props.data.channelDeliveryOptionConfig?.result ? (
            CartLineGroupItems({
                cartlines: cart.cart.CartLines,
                storeSelectorModuleId: storeSelectorId,
                cartlinesErrors,
                products: this.props.data.products.result,
                productAvailabilites: this.props.data.productAvailabilites.result,
                productDeliveryOptions: this.props.data.deliveryOptions.result,
                imageSettings,
                isStockCheckEnabled: this.props.context.app.config.enableStockCheck || false,
                maxCartlineQuantity: this.props.context.app.config.maxQuantityForCartLineItem,
                gridSettings: this.props.context.request.gridSettings!,
                context: this.props.context,
                typeName: this.props.typeName,
                id: this.props.id,
                resources: {
                    sizeString: resources.productDimensionTypeSize,
                    colorString: resources.productDimensionTypeColor,
                    configString: resources.productDimensionTypeConfiguration,
                    styleString: resources.productDimensionTypeStyle,
                    amountString: resources.productDimensionTypeAmount,
                    quantityDisplayString: resources.quantityDisplayText,
                    inputQuantityAriaLabel: resources.inputQuantityAriaLabel,
                    decrementButtonAriaLabel: resources.decrementButtonAriaLabel,
                    incrementButtonAriaLabel: resources.incrementButtonAriaLabel,
                    discountStringText: resources.discountStringText,
                    originalPriceText: resources.originalPriceText,
                    currentPriceText: resources.currentPriceText,
                    shippingChargesText: resources.shippingCharges
                },
                telemetry,
                addToWishlistButtonText: resources.addToWishlistButtonText,
                removeFromWishlistButtonText: resources.removeFromWishlistButtonText,
                removeButtonText: resources.removeCartButtonText,
                shipItText: resources.shipInsteadDisplayText,
                pickitUpText: resources.pickItUpDisplayText,
                changeStoreText: resources.changeStoreDisplayText,
                storeSelectorStateManager: this.props.data.storeSelectorStateManager.result,
                outOfStockText: resources.outOfStockErrorMessage,
                outOfRangeOneText: resources.errorMessageOutOfRangeOneLeft,
                outOfRangeFormatText: resources.errorMessageOutOfRangeFormat,
                cartState: this.props.data.cart.result,
                orgUnitLocations: this.props.data.orgUnitLocations.result,
                removeItemClickHandler: this._removeItemFromCartHandler,
                moveToWishlistSuccessHandler: this._moveToWishlistSuccessHandler,
                updateCartLinesQuantitySuccessHandler: this._updateCartlineQuantity,
                locationChangedHandler: this._fulfillmentStoreIdUpdated,
                wishlists,
                defaultWishlistName: resources.defaultWishlistName,
                pickupDeliveryModeCode: PickupDeliveryModeCode,
                includeErrors: config.showOutOfStockErrors,
                showShippingChargesForLineItems: config.showShippingChargesForLineItems,
                telemetryContent: this.telemetryContent,
                isQuantityLimitsFeatureEnabled: this.isQuantityLimitsFeatureEnabled,

                addToOrderTemplateDialogResources: this._generateAddToOrderTemplateDialogResources(resources),
                createOrderTemplateDialogResources: this._generateOrderTemplateNameDialogResources(resources),
                itemAddedToOrderTemplateDialogResources: this._generateItemAddedToOrderTemplateDialogResources(resources),
                duplicateItemsWhenAddingToOrderTemplateDialogResources: this._generateDuplicateItemsWhenAddingToOrderTemplateDialogResources(resources),

                addToOrderTemplateButtonText: resources.addToOrderTemplateButtonText,
                addToOrderTemplateButtonTooltip: resources.addToOrderTemplateButtonTooltip,
                addToOrderTemplateMessage: resources.addToOrderTemplateMessage,
                addItemToOrderTemplateError: resources.addItemToOrderTemplateError,
                orderTemplates,
                customerInformation,
                channelDeliveryOptionConfig: this.props.data.channelDeliveryOptionConfig?.result,
                shouldIgnoreWarehouse: this.props.context.app.config.warehouseAggregation === 'multiple',
                productExpirationMessage: this.props.data.expirationMessage.result?.message
            })
        ) : null;
    }

}

export default Cart;
