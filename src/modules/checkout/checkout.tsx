/*--------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * See License.txt in the project root for license information.
 *--------------------------------------------------------------*/

/* eslint-disable no-duplicate-imports */
import * as Msdyn365 from '@msdyn365-commerce/core';
import { Cart, CartLineValidationResults } from '@msdyn365-commerce/retail-proxy';
import { updateLineDeliverySpecificationsAsync, validateForCheckoutAsync } from '@msdyn365-commerce/retail-proxy/dist/DataActions/CartsDataActions.g';
import { DeliveryPreferenceType, LineDeliverySpecification, ReleasedProductType, SimpleProduct } from '@msdyn365-commerce/retail-proxy/dist/Entities/CommerceTypes.g';
import { IModuleStateManager, IModuleStateProps, withModuleState } from '@msdyn365-commerce-modules/checkout-utilities';
import { ArrayExtensions, getAvailabilitiesForCartLineItems, ProductAvailabilitiesForCartLineItems } from '@msdyn365-commerce-modules/retail-actions';
import { Button, getPayloadObject, getTelemetryAttributes, getTelemetryObject, IModuleProps, INodeProps, ITelemetryContent, TelemetryConstant, Waiting } from '@msdyn365-commerce-modules/utilities';
import classnames from 'classnames';
import isEmpty from 'lodash/isEmpty';
import { computed, reaction, when } from 'mobx';
import { observer } from 'mobx-react';
import * as React from 'react';

import { ICheckoutData } from './checkout.data';
import { ICheckoutHeadingData, ICheckoutProps } from './checkout.props.autogenerated';
import AlertComponent from './components/alert';
import { getInvoicePaymentSummary, IInvoicePaymentSummary } from './components/get-invoice-payment-summary';
import { getLineItems, ILineItems } from './components/get-line-items';
import { getOrderSummary, IOrderSummary } from './components/get-order-summary';
import GuidedFormComponent from './components/guided-form';
import PlaceOrderButtonComponent from './components/place-order-button';
import placeOrder from './methods/place-order';

export * from './components/get-line-items';
export * from './components/get-order-summary';

type DeviceType = 'Mobile';

interface ICheckoutState {
    errorMessage: string;
    isValidationPassed: boolean;
    isPlaceOrderLoading?: boolean;
}

export interface ICheckoutViewProps extends ICheckoutProps<ICheckoutData> {
    className: string;
    canShow?: boolean;
    isEmptyCart?: boolean;
    isConsentGiven?: boolean;
    hasError?: boolean;
    cartStatus?: string;
    isMobile?: boolean;
    isEditorialMode?: boolean;
    backToShoppingUrl?: string;
    editCartLink?: string;
    hasSalesOrder: boolean;
    hasInvoiceLine?: boolean;

    checkoutProps: IModuleProps;
    headerProps: INodeProps;
    bodyProps: INodeProps;
    mainProps: INodeProps;
    mainControlProps: INodeProps;
    sideProps: INodeProps;
    sideControlFirstProps: INodeProps;
    sideControlSecondProps: INodeProps;
    termsAndConditionsProps: INodeProps;

    guidedForm?: React.ReactNode;
    title?: React.ReactNode;
    loading?: React.ReactNode;
    alert?: React.ReactNode;
    orderSummary?: IOrderSummary;
    invoicePaymentSummary?: IInvoicePaymentSummary;
    lineItems?: ILineItems;
    placeOrderButton?: React.ReactNode;
    termsAndConditions?: React.ReactNode;
    keepShoppingButton?: React.ReactNode;
    orderConfirmation?: React.ReactNode;
}

export interface ICheckoutModuleProps extends ICheckoutProps<ICheckoutData>, IModuleStateProps { }

/**
 *
 * CheckoutContainer component.
 * @extends {React.Component<ICheckoutModuleProps>}
 */
// @ts-expect-error
@withModuleState
@observer
class Checkout extends React.PureComponent<ICheckoutModuleProps> {

    @computed get cartStatus(): Msdyn365.AsyncResultStatus {
        return this.props.data.checkout?.status;
    }

    @computed get isEmptyCart(): boolean {
        if (this.isEditorialMode) {
            // Editorial mode: Ignore empty cart
            return false;
        }
        const cart = this.props.data.checkout?.result?.checkoutCart?.cart;
        return this.cartStatus === 'SUCCESS' && !!cart && !isEmpty(cart) && (!cart.CartLines || cart.CartLines.length === 0);
    }

    @computed get hasError(): boolean {
        const cart = this.props.data.checkout?.result?.checkoutCart?.cart;
        return this.cartStatus === 'FAILED' || (this.cartStatus === 'SUCCESS' && (!cart || isEmpty(cart)));
    }

    @computed get isEditorialMode(): boolean {
        return this.props.context.request.params.isEditor;
    }

    @computed public get isPaymentVerificationRedirection(): boolean {
        const { requestFormData, query } = this.props.context.request;
        return !!((requestFormData || (query && query.pv === '1')));
    }

    @computed get canPlaceOrder(): boolean {
        const isTermsAndConditionAccepted = this.props.data.checkout.result && this.props.data.checkout.result?.isTermsAndConditionAccepted;

        const shouldEnableSinglePaymentAuthorizationCheckout = this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout ?? false;

        // If isTermsAndConditionAccepted is undefined means TermsAndCondition module is not added to page and we should able to place order.
        return this.props.moduleState.isReady &&
        (isTermsAndConditionAccepted === undefined ||
            isTermsAndConditionAccepted ||
            shouldEnableSinglePaymentAuthorizationCheckout) &&
        (this.state.errorMessage === '' || this.isPaymentVerificationRedirection);
    }

    @computed get isCartReady(): boolean {
        return !!this.props.data.checkout.result?.checkoutCart?.cart &&
            this.props.data.customerInformation.status !== 'LOADING' &&
            this.props.data.featureState.status !== 'LOADING';
    }

    public state: ICheckoutState = {
        errorMessage: '',
        isValidationPassed: false,
        isPlaceOrderLoading: false
    };

    private readonly telemetryContent: ITelemetryContent = getTelemetryObject(this.props.context.request.telemetryPageName!,
        this.props.friendlyName,
        this.props.telemetry);

    public componentDidMount(): void {
        const {
            resources: { genericErrorMessage }
        } = this.props;

        when(
            () => this.hasError,
            () => {
                this.setState({
                    errorMessage: genericErrorMessage
                });
                this.props.context.telemetry.error('Failed to get cart');
            }
        );

        when(
            () => {
                return this.isEmptyCart;
            },
            () => {
                this.redirectToCartPage('Cart is empty, but no editCartLink found');
            }
        );

        when(
            () => this.isCartReady,
            () => {
                this.validateForCheckout();
            }
        );

        reaction(
            () => this.props.moduleState.isReady,
            () => {
                this.onContainerReady();
            }
        );

        // Reaction to call place order when isPaymentSectionContainerReady is true for new checkout flow.
        reaction(
            () => this.props.data.checkout.result?.isPaymentSectionContainerReady,
            async (isReady) => {
                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && isReady &&
                    !this.props.data.checkout.result.redirectAdditionalContext) {
                    if (!this.state.isPlaceOrderLoading) {
                        this.setState({ isPlaceOrderLoading: true });
                    }

                    await this.onPlaceOrder();
                    this.setState({ isPlaceOrderLoading: false });
                }
            }
        );

        // Reaction to enable place order button when isPaymentSectionContainerHasError is true for new checkout flow.
        reaction(
            () => this.props.data.checkout.result?.isPaymentSectionContainerHasError,
            (hasError) => {
                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && hasError) {
                    this.setState({ isPlaceOrderLoading: false });
                }
            }
        );

        // Reaction to enable place order button when redirection is true for new checkout flow.
        reaction(
            () => this.canPlaceOrder,
            async () => {
                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && this.canPlaceOrder) {
                    const { requestFormData, query } = this.props.context.request;
                    const isRedirection = !!((requestFormData && query && query.pv === '1'));
                    if (isRedirection) {
                        await this.props.data.checkout.result.updateIsPlaceOrderEnabledInRedirection({
                            newIsPlaceOrderEnabledInRedirection: true
                        });
                    }
                }
            }
        );
    }

    // eslint-disable-next-line complexity -- ignore the complexity.
    public render(): JSX.Element {
        const {
            moduleState,
            config: { className, checkoutHeading, disableGuidedCheckoutFlow },
            resources
        } = this.props;
        const { errorMessage } = this.state;
        const { backToShopping, placeOrderText, confirmPaymentText, cookieConsentRequiredMessage, genericErrorMessage } = resources;
        const checkoutClass = classnames('ms-checkout', className);
        const checkoutInformation = this.getSlotItems('checkoutInformation');

        const isConsentGiven =
            this.props.context.request &&
            this.props.context.request.cookies &&
            this.props.context.request.cookies.isConsentGiven &&
            this.props.context.request.cookies.isConsentGiven();

        const isMobile =
            this.props.context.request &&
            this.props.context.request.device &&
            (this.props.context.request.device.Type as DeviceType) === 'Mobile';

        const backToShoppingUrl = Msdyn365.getUrlSync('home', this.props.context.actionContext) || '';
        const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';

        const termsAndConditions =
            this.props.slots.termsAndConditions &&
            this.props.slots.termsAndConditions.length > 0 &&
            this.props.slots.termsAndConditions[0];

        const payLoad = getPayloadObject('click', this.telemetryContent, TelemetryConstant.BackToShopping);
        const backToShoppingAttributes = getTelemetryAttributes(this.telemetryContent, payLoad);

        const hasInvoiceLine = this.props.data.checkout && this.props.data.checkout.result?.checkoutCart.hasInvoiceLine;
        const checkoutBtnText = hasInvoiceLine ? confirmPaymentText : placeOrderText;

        let viewProps: ICheckoutViewProps = {
            ...this.props,
            className: checkoutClass,
            isEmptyCart: this.isEmptyCart,
            isConsentGiven,
            hasError: this.hasError,
            hasSalesOrder: this.props.data.checkout && this.props.data.checkout.result !== undefined && this.props.data.checkout.result.salesOrder !== undefined,
            hasInvoiceLine,
            cartStatus: this.cartStatus,
            isMobile,
            backToShoppingUrl,
            editCartLink,
            isEditorialMode: this.isEditorialMode,
            orderConfirmation: this.props.slots.orderConfirmation && this.props.slots.orderConfirmation.length > 0 ? this.props.slots.orderConfirmation[0] : undefined,
            checkoutProps: { moduleProps: this.props, className: checkoutClass },
            headerProps: { className: 'ms-checkout__head' },
            bodyProps: { className: 'ms-checkout__body' },
            mainProps: { className: 'ms-checkout__main' },
            mainControlProps: { className: 'ms-checkout__main-control' },
            sideProps: { className: 'ms-checkout__side' },
            sideControlFirstProps: { className: 'ms-checkout__side-control-first' },
            sideControlSecondProps: { className: 'ms-checkout__side-control-second' },
            termsAndConditionsProps: { className: 'ms-checkout__terms-and-conditions' },
            title: checkoutHeading && (
                this.renderMsdyn365Text(checkoutHeading)
            )
        };

        if (!isConsentGiven) {
            viewProps = {
                ...viewProps,
                alert: <AlertComponent {...{ message: cookieConsentRequiredMessage }} />
            };
        } else if (this.isLoading()) {
            viewProps = {
                ...viewProps,
                loading: <Waiting className='msc-waiting-circular msc-waiting-lg' />
            };
        } else if (this.hasError) {
            viewProps = {
                ...viewProps,
                alert: <AlertComponent {...{ message: genericErrorMessage }} />
            };
        } else {
            const shouldEnableSinglePaymentAuthorizationCheckout: boolean =
                this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout ?? false;

            viewProps = {
                ...viewProps,
                alert: errorMessage && <AlertComponent {...{ message: errorMessage }} />,
                canShow: true,
                guidedForm: checkoutInformation ? (
                    <GuidedFormComponent
                        {...{
                            items: checkoutInformation,
                            moduleState,
                            disableGuidedCheckoutFlow,
                            resource: resources,
                            requestContext: this.props.context,
                            isMobile,
                            isEditor: this.isEditorialMode,
                            telemetryContent: this.telemetryContent
                        }}
                    />
                ) : (
                    undefined
                ),
                orderSummary: getOrderSummary(this.props),
                invoicePaymentSummary: getInvoicePaymentSummary(this.props),
                lineItems: hasInvoiceLine ? undefined : getLineItems(this.props, this.telemetryContent),
                placeOrderButton: (
                    <PlaceOrderButtonComponent {...{
                        checkoutBtnText,
                        placeOrder: shouldEnableSinglePaymentAuthorizationCheckout ? this.triggerPaymentWithPlaceOrder : this.onPlaceOrder,
                        canPlaceOrder: this.canPlaceOrder,
                        telemetryContent: this.telemetryContent,
                        shouldEnableSinglePaymentAuthorizationCheckout: this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout,
                        isPlaceOrderLoading: this.state.isPlaceOrderLoading
                    }} />
                ),
                termsAndConditions,
                keepShoppingButton: backToShoppingUrl && (
                    <Button
                        className='ms-checkout__btn-keep-shopping msc-btn'
                        title={backToShopping}
                        color='secondary'
                        href={backToShoppingUrl}
                        {...backToShoppingAttributes}
                    >
                        {backToShopping}
                    </Button>
                )
            };
        }

        return this.props.renderView(viewProps) as React.ReactElement;
    }

    public renderMsdyn365Text(checkoutHeading: ICheckoutHeadingData): React.ReactNode {
        return (
            <Msdyn365.Text
                {...checkoutHeading}
                tag={checkoutHeading.tag || 'h2'}
                className='ms-checkout__title'
                text={checkoutHeading.text}
                editProps={{ onEdit: this.handleCheckoutHeadingChange, requestContext: this.props.context.request }}
            />
        );
    }

    public handleCheckoutHeadingChange = (event: Msdyn365.ContentEditableEvent) => this.props.config.checkoutHeading!.text = event.target.value;

    private readonly isLoading = (): boolean => {
        return !this.cartStatus || this.cartStatus === 'LOADING' || this.isEmptyCart || !this.state.isValidationPassed;
    };

    private readonly getSlotItems = (key: string): React.ReactNode[] | undefined => {
        const { slots } = this.props;
        return slots && slots[key] && slots[key].length > 0 ? slots[key] : undefined;
    };

    /**
     * Trigger the payment section container submit when placing order.
     */
    private readonly triggerPaymentWithPlaceOrder = async (): Promise<void> => {
        this.setState({ isPlaceOrderLoading: true });

        await this.props.data.checkout.result?.updateShouldTriggerPaymentWithPlaceOrder(
            { newShouldTriggerPaymentWithPlaceOrder: !this.props.data.checkout.result.shouldTriggerPaymentWithPlaceOrder });
    };

    private readonly onPlaceOrder = async (): Promise<void> => {
        const {
            resources: { checkoutOutOfStockErrorMessage, genericErrorMessage, invalidCartVersionErrorMessage },
            context: { actionContext, app: { config: { enableStockCheck = false } } },
            slots: { orderConfirmation },
            data: { checkout, products }
        } = this.props;

        // If hasInvoiceLine is true, no inventory check
        if (!this.props.data.checkout.result?.checkoutCart.hasInvoiceLine && enableStockCheck &&
            await this.isOverMaxQuantity((await checkout).checkoutCart.cart, (await products))) {
            this.setState({
                errorMessage: checkoutOutOfStockErrorMessage
            });
            this.props.context.telemetry.error(checkoutOutOfStockErrorMessage);
        } else {
            const hasOrderConfirmation = orderConfirmation && orderConfirmation.length > 0;

            const updatedCartVersion = await this.updateCartLineEmailAddress(this.props.data.checkout.result?.guestCheckoutEmail || '');

            await placeOrder(actionContext, this.props.data.checkout.result, this.props.data.products.result,
                !hasOrderConfirmation, updatedCartVersion, this.isPaymentVerificationRedirection).catch(error => {
                let errorMessage = genericErrorMessage;

                if (error && error.name === 'Microsoft_Dynamics_Commerce_Runtime_InvalidCartVersion') {
                    errorMessage = invalidCartVersionErrorMessage;
                }

                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access -- unknown error type.
                if (this.props.data.checkout.result?.shouldEnableSinglePaymentAuthorizationCheckout && error.data?.AdditionalContext &&
                    !this.isPaymentVerificationRedirection) {
                    return;
                }

                this.setState({
                    errorMessage
                });
                this.props.telemetry.exception(error);
            });
        }
    };

    // Update receipt email address for electronic cart line
    // return the updated cart version
    private readonly updateCartLineEmailAddress = async (newGuestCheckoutEmail: string): Promise<number | undefined> => {
        const emailDeliveryModeCode = this.props.context.request.channel?.EmailDeliveryModeCode;

        const emailDeliveryCartLines = this.props.data.checkout.result?.checkoutCart.cart.CartLines?.filter(
            cartLine => (cartLine.DeliveryMode && cartLine.DeliveryMode !== '' && cartLine.DeliveryMode === emailDeliveryModeCode)
        );

        let updatedCartVersion: number | undefined;
        if (emailDeliveryCartLines && emailDeliveryCartLines.length > 0) {
            const lineDeliverySpecifications: LineDeliverySpecification[] = emailDeliveryCartLines.map(line => {
                return { LineId: line.LineId,
                    DeliverySpecification: {
                        DeliveryModeId: emailDeliveryModeCode,
                        DeliveryPreferenceTypeValue: DeliveryPreferenceType.ElectronicDelivery,
                        ElectronicDeliveryEmailAddress: newGuestCheckoutEmail
                    }
                };
            });

            await updateLineDeliverySpecificationsAsync(
                { callerContext: this.props.context.actionContext },
                (await this.props.data.checkout).checkoutCart.cart.Id,
                lineDeliverySpecifications
            ).then(updatedCart => {
                updatedCartVersion = updatedCart.Version;
            }).catch(error => {
                this.props.context.actionContext.telemetry.exception(error);
                throw new Error('[updateLineDeliverySpecificationsAsync] Unable to update electronic delivery email address in cart');
            });
        }

        return updatedCartVersion;
    };

    /**
     * Return true if any product in the cart is over its max quantity.
     * @param cart -- The checkout cart.
     * @param products -- The checkout products.
     * @returns -- Is any product in the cart is over max quantity.
     */
    private readonly isOverMaxQuantity = async (cart: Cart, products: SimpleProduct[]): Promise<boolean> => {
        let isOverMaxQuantity = false;
        const emailDeliveryModeCode = this.props.context.request.channel?.EmailDeliveryModeCode;

        await getAvailabilitiesForCartLineItems(
            new ProductAvailabilitiesForCartLineItems(this.props.context.actionContext.requestContext.apiSettings),
            this.props.context.actionContext
        ).then(productInventoryInformation => {
            cart.CartLines?.map((cartline) => {

                const cartlineProduct = products.find(product => product.RecordId === cartline.ProductId);
                const isServiceItem = cartlineProduct?.ItemTypeValue === ReleasedProductType.Service;

                // If product is service item or cartline is electronic delivery, then no inventory check
                if (!isServiceItem && cartline.DeliveryMode !== emailDeliveryModeCode && ArrayExtensions.hasElements(productInventoryInformation)) {
                    const foundProductAvailability = productInventoryInformation.find((productInventory) => {
                        return productInventory.ProductAvailableQuantity?.ProductId! === cartline.ProductId;
                    });

                    if (!(foundProductAvailability?.IsProductAvailable && foundProductAvailability.ProductAvailableQuantity.AvailableQuantity !== undefined &&
                        cartline.Quantity && cartline.Quantity <= foundProductAvailability.ProductAvailableQuantity.AvailableQuantity)) {
                        isOverMaxQuantity = true;
                    }
                }
            });

            return isOverMaxQuantity;
        })
            .catch(error => {
                this.props.context.actionContext.telemetry.exception(error);
                throw new Error('[getAvailabilitiesForCartLineItems] Unable to get availabilities for products in checkout cart');
            });

        return isOverMaxQuantity;
    };

    private readonly getActiveChildModuleStates = (): IModuleStateManager[] => {
        const { childIds, getModule } = this.props.moduleState;
        return childIds
            .map(getModule)
            .filter((state): state is IModuleStateManager => !!state && !state.isDisabled && state.hasModuleState);
    };

    private readonly onContainerReady = (): void => {
        this.getActiveChildModuleStates().forEach(state => {
            state.isReady && state.onContainerReady && state.onContainerReady();
        });
    };

    private readonly redirectToCartPage = (notFoundEditCartLinkMessage: string): void => {
        const editCartLink = Msdyn365.getUrlSync('cart', this.props.context.actionContext) || '';
        if (window && editCartLink) {
            window.location.assign(editCartLink);
        } else {
            this.setState({
                errorMessage: this.props.resources.genericErrorMessage
            });
            this.props.context.telemetry.error(notFoundEditCartLinkMessage);
        }
    };

    private readonly validateForCheckout = (retry: boolean = true): void => {
        const notFoundEditCartLinkMessage = 'Cart doesn\'t pass validation, but no editCartLink found';
        const cart = this.props.data.checkout.result!.checkoutCart.cart;
        const { Id, Version } = cart;
        const isOrderQuantityLimitsFeatureEnabledInHq = this.props.data.featureState.result
            ?.find(featureState => featureState.Name === 'Dynamics.AX.Application.RetailDefaultOrderQuantityLimitsFeature')?.IsEnabled || false;
        const defaultOrderQuantityLimitsFeatureConfig = this.props.context?.request?.app?.platform?.enableDefaultOrderQuantityLimits;
        const customerInfo = this.props.data.customerInformation.result;

        const isOrderQuantityLimitsFeatureEnabledInSiteSettings = defaultOrderQuantityLimitsFeatureConfig === 'all' ||
            (customerInfo &&
            ((defaultOrderQuantityLimitsFeatureConfig === 'b2b' && customerInfo.IsB2b) ||
            (defaultOrderQuantityLimitsFeatureConfig === 'b2c' && !customerInfo.IsB2b)));
        if (isOrderQuantityLimitsFeatureEnabledInHq && isOrderQuantityLimitsFeatureEnabledInSiteSettings) {
            if (Version && Id) {
                validateForCheckoutAsync({ callerContext: this.props.context.actionContext, bypassCache: 'none' }, Id, Version)
                    .then((result: CartLineValidationResults) => {
                        if (result.ValidationFailuresByCartLines?.length !== 0) {
                            this.redirectToCartPage(notFoundEditCartLinkMessage);
                        } else {
                            this.setState({ isValidationPassed: true });
                        }
                    })
                    .catch((error) => {
                        this.props.telemetry.warning(error);
                        this.props.telemetry.debug('Unable to validate Cart');
                        if (retry && error.name === 'Microsoft_Dynamics_Commerce_Runtime_InvalidCartVersion') {
                            const cartState = this.props.data.checkout.result?.checkoutCart;
                            cartState?.refreshCart({})
                                .then(() => {
                                    this.validateForCheckout(false);
                                })
                                .catch((refreshError: Error) => {
                                    this.props.telemetry.warning(refreshError.message);
                                    this.props.telemetry.debug('Unable to refresh Cart');
                                });
                        } else {
                            this.redirectToCartPage(notFoundEditCartLinkMessage);
                        }
                    });
            } else {
                this.redirectToCartPage(notFoundEditCartLinkMessage);
            }
        } else {
            this.setState({ isValidationPassed: true });
        }
    };
}

export default Checkout;
